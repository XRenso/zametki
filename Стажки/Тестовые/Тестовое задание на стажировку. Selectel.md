# Отчёт по отладке приложения Одерий Ярослав

## Шаг 1: Анализ и первоначальный запуск

### Что сделал:
- Проанализировал структуру проекта
- Обнаружил отсутствие `.env` файла
- Создал `.env` с необходимыми переменными окружения

### Проблема:
Приложение не могло запуститься из-за отсутствия файла с переменными окружения.

### Решение:
Создал `.env` файл с переменными:
```env
DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/postgres
LOG_LEVEL=INFO
PARSE_SCHEDULE_MINUTES=5
```

---

## Шаг 2: Исправление критических багов конфигурации

### БАГ #1: Опечатка в названии переменной окружения
**Файл:** `app/core/config.py:14`

**Что сделал:** Обнаружил опечатку при первом запуске приложения

**Проблема:** 
Приложение падало с ошибкой валидации Pydantic:
```
pydantic_core._pydantic_core.ValidationError: 1 validation error for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden]
```

**Файл и строка:** `app/core/config.py:14`

**Код до:**
```python
database_url: str = Field(
    "postgresql+asyncpg://postgres:postgres@db:5432/postgres_typo",
    validation_alias="DATABSE_URL",
)
```

**Код после:**
```python
database_url: str = Field(
    default="postgresql+asyncpg://postgres:postgres@db:5432/postgres",
    alias="DATABASE_URL",
)
```

**Причина:** В `validation_alias` была опечатка - `DATABSE_URL` вместо `DATABASE_URL`, что приводило к невозможности чтения переменной окружения.

---

### БАГ #2: Отсутствие alias для полей конфигурации
**Файл:** `app/core/config.py`

**Что сделал:** Добавил правильную конфигурацию Pydantic Settings

**Проблема:**
При запуске сервиса Pydantic не мог корректно прочитать переменные окружения `LOG_LEVEL` и `PARSE_SCHEDULE_MINUTES`, что вызывало ошибку валидации.

**Код до:**
```python
log_level: str = "INFO"
parse_schedule_minutes: int = 5
```

**Код после:**
```python
log_level: str = Field(default="INFO", alias="LOG_LEVEL")
parse_schedule_minutes: int = Field(default=5, alias="PARSE_SCHEDULE_MINUTES")
```

**Причина:** Без явного указания `alias`, Pydantic Settings не мог корректно маппить переменные окружения в UPPER_CASE на поля модели в snake_case.

---

## Шаг 3: Исправление багов парсера

### БАГ #3: Отсутствие проверки на None для поля city
**Файл:** `app/services/parser.py:43`

**Что сделал:** Добавил проверку на None перед обращением к атрибуту

**Проблема:**
Парсер падал с ошибкой при обработке удаленных вакансий без указания города:
```
AttributeError: 'NoneType' object has no attribute 'name'
```

**Файл и строка:** `app/services/parser.py:43`

**Код до:**
```python
"city_name": item.city.name.strip(),
```

**Код после:**
```python
"city_name": item.city.name.strip() if item.city else None,
```

**Причина:** API Selectel возвращает `city: null` для удаленных вакансий. Код не обрабатывал этот случай и пытался вызвать метод `.name` на `None`.

---

### БАГ #4: Неправильная единица измерения времени в планировщике
**Файл:** `app/services/scheduler.py:13`

**Что сделал:** Исправил параметр с `seconds` на `minutes`

**Проблема:**
Парсинг запускался каждые 5 **секунд** вместо 5 **минут**, что создавало избыточную нагрузку на внешний API и базу данных.

**Файл и строка:** `app/services/scheduler.py:13`

**Код до:**
```python
scheduler.add_job(
    job,
    trigger="interval",
    seconds=settings.parse_schedule_minutes,
    coalesce=True,
    max_instances=1,
)
```

**Код после:**
```python
scheduler.add_job(
    job,
    trigger="interval",
    minutes=settings.parse_schedule_minutes,
    coalesce=True,
    max_instances=1,
)
```

**Причина:** Неправильный параметр в APScheduler - использовались `seconds` вместо `minutes`.

---

### БАГ #5: Утечка ресурсов HTTP клиента
**Файл:** `app/services/parser.py:31`

**Что сделал:** Добавил контекстный менеджер для автоматического закрытия клиента

**Проблема:**
HTTP клиент создавался, но никогда не закрывался, что приводило к утечке соединений и файловых дескрипторов.

**Файл и строка:** `app/services/parser.py:31`

**Код до:**
```python
try:
    client = httpx.AsyncClient(timeout=timeout)
    page = 1
    while True:
        payload = await fetch_page(client, page)
except (httpx.RequestError, httpx.HTTPStatusError) as exc:
    logger.exception("Ошибка парсинга вакансий: %s", exc)
    return 0
```

**Код после:**
```python
try:
    async with httpx.AsyncClient(timeout=timeout) as client:
        page = 1
        while True:
            payload = await fetch_page(client, page)
except (httpx.RequestError, httpx.HTTPStatusError) as exc:
    logger.exception("Ошибка парсинга вакансий: %s", exc)
    return 0
```

**Причина:** Не использовался `async with`, который гарантирует закрытие HTTP соединений даже при возникновении исключений.

---

## Шаг 4: Исправление багов API

### БАГ #6: Неправильный тип ответа при дубликате external_id
**Файл:** `app/api/v1/vacancies.py:51`

**Что сделал:** Заменил `JSONResponse` на `HTTPException`

**Проблема:**
Эндпоинт `POST /api/v1/vacancies/` возвращал `JSONResponse` при обнаружении дубликата, что нарушало контракт API (`response_model=VacancyRead`). Также был некорректный HTTP status code

**Файл и строка:** `app/api/v1/vacancies.py:51-54`

**Код до:**
```python
if existing:
    return JSONResponse(  
        status_code=status.HTTP_200_OK,
        content={"detail": "Vacancy with external_id already exists"},
    )
```

**Код после:**
```python
if existing:
    raise HTTPException(
        status_code=status.HTTP_409_CONFLICT,
        detail="Vacancy with external_id already exists"
    )
```

**Причина:** 
- Неправильное использование `JSONResponse` вместо исключения
- HTTP 200 вместо HTTP 409
- Клиенты ожидали объект `VacancyRead`, получали текстовое сообщение

---

## Шаг 5: Оптимизация и безопасность

### БАГ #7: Проблема N запросов при парсинге вакансий
**Файл:** `app/crud/vacancy.py:78`

**Что сделал:** Оптимизировал загрузку существующих вакансий до одного запроса

**Проблема:**
При парсинге N вакансий выполнялось N запросов к базе данных - по одному для каждой существующей вакансии.

**Файл и строка:** `app/crud/vacancy.py:78-82`

**Код до:**
```python
for payload in payloads:
    ext_id = payload["external_id"]
    if ext_id and ext_id in existing_ids:
        result = await session.execute(
            select(Vacancy).where(Vacancy.external_id == ext_id)
        )
        vacancy = result.scalar_one()
        for field, value in payload.items():
            setattr(vacancy, field, value)
```

**Код после:**
```python
existing_vacancies = {}
if external_ids:
    existing_result = await session.execute(
        select(Vacancy).where(Vacancy.external_id.in_(external_ids))
    )
    existing_vacancies = {v.external_id: v for v in existing_result.scalars().all()}

for payload in payloads:
    ext_id = payload["external_id"]
    if ext_id and ext_id in existing_vacancies:
        vacancy = existing_vacancies[ext_id]
        for field, value in payload.items():
            setattr(vacancy, field, value)
```

**Причина:** Классическая проблема, для каждого элемента в цикле выполнялся отдельный SQL запрос вместо одного пакетного.

---

### БАГ #8: Отсутствие экранирования спецсимволов в LIKE запросах
**Файл:** `app/crud/vacancy.py:32`

**Что сделал:** Добавил экранирование специальных символов SQL

**Проблема:**
Пользователь мог передать в фильтр символы `%` или `_`, которые имеют специальное значение в SQL LIKE, что нарушало логику фильтрации и могло использоваться для обхода фильтров.

**Файл и строка:** `app/crud/vacancy.py:32-34`

**Код до:**
```python
if timetable_mode_name:
    stmt = stmt.where(
        Vacancy.timetable_mode_name.ilike(f"%{timetable_mode_name}%")
    )
```

**Код после:**
```python
if timetable_mode_name:
    escaped_mode = (
        timetable_mode_name.replace("\\", "\\\\")
        .replace("%", "\\%")
        .replace("_", "\\_")
    )
    stmt = stmt.where(
        Vacancy.timetable_mode_name.ilike(f"%{escaped_mode}%", escape="\\")
    )
```

**Причина:** Специальные символы SQL LIKE (`%` - любые символы, `_` - один символ) не экранировались.

---

### БАГ #9: Несоответствие типов данных в upsert
**Файл:** `app/crud/vacancy.py:87`

**Что сделал:** Изменил `existing_ids` на `existing_vacancies` со словарем

**Проблема:**
В коде использовалась переменная `existing_ids = {}` (пустой словарь) вместо `set()`, что семантически неверно и могло привести к путанице.

**Файл и строка:** `app/crud/vacancy.py:73`

**Код до:**
```python
if external_ids:
    existing_result = await session.execute(
        select(Vacancy.external_id).where(Vacancy.external_id.in_(external_ids))
    )
    existing_ids = set(existing_result.scalars().all())
else:
    existing_ids = {}
```

**Код после:**
```python
existing_vacancies = {}
if external_ids:
    existing_result = await session.execute(
        select(Vacancy).where(Vacancy.external_id.in_(external_ids))
    )
    existing_vacancies = {v.external_id: v for v in existing_result.scalars().all()}
```

**Причина:** 
- Изначально использовался `set` для хранения ID, но при пустом случае создавался `dict`
- После рефакторинга (БАГ #7) стал использоваться словарь для маппинга, что логичнее
- Обеспечивается единство типов и упрощается логика

---

## Шаг 6: Тестирование

### Что сделал:
Создал полноценную тестовую инфраструктуру с pytest

### Результаты тестирования:
```bash
===================================================================== test session starts =====================================================================
platform linux -- Python 3.11.14, pytest-9.0.2, pluggy-1.6.0
collected 18 items

tests/test_crud.py::test_create_vacancy PASSED                                  [  5%]
tests/test_crud.py::test_get_vacancy PASSED                                     [ 11%]
tests/test_crud.py::test_get_vacancy_not_found PASSED                           [ 16%]
tests/test_crud.py::test_get_vacancy_by_external_id PASSED                      [ 22%]
tests/test_crud.py::test_list_vacancies_no_filter PASSED                        [ 27%]
tests/test_crud.py::test_list_vacancies_filter_by_city PASSED                   [ 33%]
tests/test_crud.py::test_list_vacancies_filter_by_timetable PASSED              [ 38%]
tests/test_crud.py::test_list_vacancies_escape_special_chars PASSED             [ 44%]
tests/test_crud.py::test_update_vacancy PASSED                                  [ 50%]
tests/test_crud.py::test_delete_vacancy PASSED                                  [ 55%]
tests/test_crud.py::test_upsert_create_new_vacancies PASSED                     [ 61%]
tests/test_crud.py::test_upsert_update_existing_vacancies PASSED                [ 66%]
tests/test_crud.py::test_upsert_mixed_create_and_update PASSED                  [ 72%]
tests/test_parser.py::test_fetch_page_success PASSED                            [ 77%]
tests/test_parser.py::test_parse_and_store_success PASSED                       [ 83%]
tests/test_parser.py::test_parse_and_store_handles_none_city PASSED             [ 88%]
tests/test_parser.py::test_parse_and_store_http_error PASSED                    [ 94%]
tests/test_parser.py::test_parse_and_store_multiple_pages PASSED                [100%]

===================================================================== 18 passed in 0.93s ==========================================================
```

### Покрытие тестами:

**CRUD операции (13 тестов):**
- Создание, чтение, обновление, удаление вакансий
- Фильтрация по городу и режиму работы
- Обработка несуществующих записей (404)
- Экранирование SQL спецсимволов
- Upsert логика (создание и обновление)

**Парсер (5 тестов):**
- Получение данных из API
- Обработка пагинации
- Обработка `city=None`
- Обработка сетевых ошибок
- Закрытие HTTP соединений

## Итоги

1. **Создан .env файл** 
   - С необходимыми переменными окружения
2. **Исправлено 9 багов:**
   - Сервис теперь корректно работает
3. **Создано 18 unit тестов** 
   - Покрытие основной функциональности для parser и crud
4. **Оптимизации:**
   - Парсинг: N вакансий N запросов
   - Добавлено экранирование SQL спецсимволов
5. **Исправлены утечки ресурсов:**
   - HTTP клиенты теперь корректно закрываются
6. **Приложен скриншоты**
   - Swagger UI с успешно выполненными запросами

