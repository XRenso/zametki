```c
fun my_inc (int *a){
	*a = *a +1;
}
```

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|      b=0      |      b=0      |
|  my_inc(&b)   |  my_inc(&b)   |
b - локальная

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|      c=0      |      c=0      |
|  my_inc(&c)   |  my_inc(&c)   |
c - общая

При последовательном выполнении потоков T<sub>1</sub> -> T<sub>2</sub> c будет равна 2.

Race condition (состояние гонки) - Потоки одновременно работают с общей частью памяти и изменяют ее.

Блокировка данных между потоками:
```c
fun my_inc (sharedint *a){
	a.Lock();
	*a = *a +1;
	a.Unlock();
}
```

Блокирующая синхронизация - с данными может работать в одно время только 1 поток

Неблокирующая синхронизация - нет этапов (чтение, действие, запись). Работает с atomic операциями.

```c
atomic.inc(a)
```

## Синхронизация:

| блокирущая | неблокирущая                                        |
| ---------- | --------------------------------------------------- |
|            | obstruction free                                    |
|            | lock free<br>(хотя бы один поток совершит действие) |
|            | wait free <br>(конечное время выполнения)           |

### lock free
cmp_xcg ~ compare_and_set (CAS)
(add, expected, new
```c
old = addr
if (addr == expected) then addr=new
return old
```

```c
my_inc
 while (True){
	 old = atomic.read(addr)
	 if (CAS(addr, old, old+1) == old)
		 break;
 }
```



## Критическая секция 
- lock | Acquire
- Критическая секция - последовательность кода в которой находится может только 1 поток
- unlock | Release

### Свойства
1) Mutial exclusion
2) deadlock freedom (внутри метода `lock`)
3) Starvation freedom


Conditional locking - делаем try lock, в зависимости от результата выполняем некую логику
- Acquire all locks first (убрать все блокировки)

Lock order - дать порядок секциям



Lock One - через флаги блокируем и ждем, пока не спадает флаг с ожидания. Если оба пытаются получить доступ к данным deadlock

Lock Two - передаем victim поток, которому нужна критическая секция.  Нет deadlock. Проблема гололания, может никогда не наступить второй поток

### Алгоритм блокировки Петерсона (синхронизация двух потоков)
Есть массив флагов и переменная `victim`

Когда мы блокируем крит. секцию, то ствим свой `id` в массиве флагов на `True`
ставим `victim` себя
ждем пока кто-то другой работает или кто-нибудь не поменяет `victim`

## Алгоритмы синхронизации N потоков

атомарными операциями чтения и записи можно синхронизировать только ограниченное количество потоков.

### FilterLock
Есть количество уровней по количеству потоков, уровни сужуются к низу. 

При N=4, то
4 Уровня:
1. 4 Потока
2. 3 Потока
3. 2 Потока
4. 1 Поток

### Алгоритм Lamport Backery

Есть массив флагов, который говорит хочет или нет заблокировать поток с id. Есть `labels` - массив с номерками (исчет максимум+1), упорядочены у кого меньше id, тот в приоритете.

Есть случай с голоданием, когда поток после завершения может снова зайти в цикл и получит больший номер и снова будет в приоритете.


## Доп материалы:
- Deadlock Empire